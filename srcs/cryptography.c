#include "dcrypt.h"

/*
 * Perform AES-128 CBC encryption
 * -------------------------------
 *
 * Chaining:
 * --------
 * In CBC mode, each plaintext block is XORed with the previous ciphertext
 *  block before being encrypted.
 * This means that the encryption of each block depends on the previous
 *  block's ciphertext, which enhances security.
 * 
 * IV (Initialization Vector):
 * --------------------------
 * The IV is a random value used to ensure that identical plaintext blocks
 *  produce different ciphertexts.
 * This prevents patterns from appearing in the encrypted data.
 * 
 * Without IV (= NULL IV) the process will be faster, but less secure.
 * Identical plaintexts will produce identical ciphertexts.
 *
 * Padding:
 * -------
 * When using OpenSSL's EVP functions for encryption, the default padding
 *  scheme used is PKCS#7 padding.
 * 
 * How PKCS#7 Padding Works:
 *  If the plaintext data is not a multiple of the block size (16 bytes for
 *      AES), PKCS#7 padding adds bytes to the end of the plaintext.
 */

 int aes_encrypt_data(
    unsigned char       *data,
    size_t              data_len,
    const unsigned char *key,
    unsigned char       *iv
) {
    // A structure that holds the context for the encryption operation
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        return -1; // Context creation error
    }

    // Initialize the encryption operation
    if (EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1; // Initialization error
    }

    int out_len;
    // Perform the encryption of data in 16 bytes chunk
    if (EVP_EncryptUpdate(ctx, data, &out_len, data, data_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1; // Encryption error
    }

    int final_len;
    // Write any remaining encrypted data, adding paddings if needed
    if (EVP_EncryptFinal_ex(ctx, data + out_len, &final_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1; // Finalization error
    }

    EVP_CIPHER_CTX_free(ctx);
    return out_len + final_len; // Return the total length of the encrypted data
}

// Function to handle AES-128 CBC decryption
int aes_decrypt_data(
    unsigned char       *data,
    size_t              data_len,
    const unsigned char *key,
    unsigned char       *iv
) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        return -1; // Context creation error
    }

    // Initialize the decryption operation
    if (EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1; // Initialization error
    }

    int out_len;
    if (EVP_DecryptUpdate(ctx, data, &out_len, data, data_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1; // Decryption error
    }

    int final_len;
    if (EVP_DecryptFinal_ex(ctx, data + out_len, &final_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1; // Finalization error
    }

    EVP_CIPHER_CTX_free(ctx);
    return out_len + final_len; // Return the total length of the decrypted data
}

/*
 * Generates an encryption key randomly.
 *
 *  - charset: a set of characters that can be used for the key
 *  - strength: the width of the key
 */

unsigned char *keygen(const char *charset, size_t strength)
{
    unsigned char *key = malloc((strength + 1) * sizeof(char));
    // Exit in case malloc fails
    if (key == NULL) return NULL;

    int charset_length = strlen(charset);

    // Set the seed for the random number generator used by the rand() function.
    // By providing a seed, we can ensure that the sequence of random numbers
    // generated by rand() is different each time your program runs.
    // The seed is set according to the current time, which makes it unique.
    srand(time(NULL));

    for (size_t i = 0; i < strength; ++i)
    {
        int random_index = rand() % charset_length;
        // Pick a random position from the charset
        key[i] = charset[random_index];
    }
    key[strength] = '\0'; // null-terminate the key

    return key;
}

unsigned char *get_encryption_key(t_env *env)
{
	// In decryption mode, we use the key saved in the file header
	if (env->modes & DC_REVERSE)
	{
        // if (env->decryption_key) return env->decryption_key;

		// key = (unsigned char *)env->dcrypt_header.encryption_key;

		if (env->modes & DC_VERBOSE)
			printf(
                FMT_INFO
                " Using encryption key => " FMT_YELLOW "%s\n" FMT_RESET,
                env->decryption_key
            );
        return env->decryption_key;
	}
	else // In encryption mode, we generate a new encryption key
	{
        if (env->encryption_key) return env->encryption_key;
		// Generate the key that will be used for the encryption
		env->encryption_key = keygen(DC_KEYCHARSET, DC_AES_KEY_SIZE);
		if (!env->encryption_key) return NULL;

		// Save the key on the custom header
		// memcpy(env->dcrypt_header.encryption_key, key, DC_ENCRYPT_KEY_SIZE);

		if (env->modes & DC_VERBOSE)
			printf(
                FMT_INFO
                " Generated random key => " FMT_YELLOW "%s\n" FMT_RESET,
                env->encryption_key
            );
        return env->encryption_key;
	}
}
